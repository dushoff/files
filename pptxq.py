
# -*- coding: utf-8 -*-
"""
Script: pptx_to_quarto.py

Convert a PowerPoint (.pptx) into a clean, human‑readable Quarto (.qmd).

Goals
-----
• Extract slide titles, text (with bullet structure), tables (as Markdown tables),
  images (exported to a media folder and referenced in the .qmd),
  and attempt to convert Office Math (OMML) equations to LaTeX.
• Output is a single .qmd suitable for Quarto (default format: revealjs).
• Equations: best‑effort OMML → LaTeX for common constructs (fractions, super/subscripts,
  roots). When uncertain, leave an easy‑to‑search placeholder and include the
  raw OMML inside an HTML comment for manual cleanup.

Usage
-----
python pptx_to_quarto.py input.pptx -o output.qmd --format revealjs

Notes
-----
• Requires python-pptx (preinstalled in many environments).
• OMML parsing is heuristic. For perfect fidelity, consider a future enhancement that
  shells out to Pandoc or applies a full OMML→MathML→LaTeX pipeline.

Author: Generated by M365 Copilot for Jonathan Dushoff
"""

import argparse
import os
import re
import sys

from pptx import Presentation
from pptx.enum.shapes import MSO_SHAPE_TYPE

try:
	from lxml import etree as ET  # preferred for xpath
	xml_has_lxml = True
except Exception:
	import xml.etree.ElementTree as ET
	xml_has_lxml = False

A_NS = "http://schemas.openxmlformats.org/drawingml/2006/main"
M_NS = "http://schemas.openxmlformats.org/officeDocument/2006/math"
P_NS = "http://schemas.openxmlformats.org/presentationml/2006/main"

NSMAP = {"a": A_NS, "m": M_NS, "p": P_NS}


def safe_mkdir(path: str) -> None:
	if not os.path.isdir(path):
		os.makedirs(path, exist_ok=True)


def normalize_text(s: str) -> str:
	"""Normalize whitespace; preserve intentional single spaces; strip trailing."""
	if s is None:
		return ""
	# Collapse runs of spaces/tabs; preserve newlines added explicitly later.
	s = re.sub(r"[ \t\u00A0]+", " ", s)
	return s.rstrip()


def md_escape(text: str) -> str:
	"""Escape Markdown control chars minimally where they could cause issues."""
	if not text:
		return ""
	# Don’t over-escape. Handle asterisk and underscore in plain text.
	text = text.replace("\\", "\\\\")
	text = text.replace("*", "\\*")
	text = text.replace("_", "\\_")
	text = text.replace("`", "\\`")
	return text


def run_text_with_basic_formatting(p) -> str:
	"""Best-effort run-level bold/italic to Markdown. p is a paragraph object."""
	acc = []
	for run in p.runs:
		text = normalize_text(run.text)
		if not text:
			continue
		prefix = suffix = ""
		try:
			if run.font.bold:
				prefix += "**"; suffix = "**" + suffix
		except Exception:
			pass
		try:
			if run.font.italic:
				prefix += "*"; suffix = "*" + suffix
		except Exception:
			pass
		acc.append(f"{prefix}{md_escape(text)}{suffix}")
	return "".join(acc)


# -------------------- OMML → LaTeX (minimal) --------------------

def _tex_group(s: str) -> str:
	return "{" + s + "}"


def _concat_texts(nodes) -> str:
	"""Concatenate all a:t text under given nodes."""
	texts = []
	for node in nodes:
		for t in node.findall(f".//{{{A_NS}}}t"):
			if t.text:
				texts.append(t.text)
	return "".join(texts)


def omml_to_latex(elem: ET._Element) -> str:
	"""Very small subset of OMML → LaTeX.
	Handles: m:f (fraction), m:sSup (superscript), m:sSub (subscript), m:rad (root),
	and raw text runs (m:t or a:t). Falls back to concatenating raw text.
	"""
	if elem is None:
		return ""

	# Helper: detect node tag localname
	def lname(e):
		if e is None or not hasattr(e, "tag"):
			return ""
		tag = e.tag
		if "}" in tag:
			return tag.split("}", 1)[1]
		return tag

	# Direct text tokens that might appear inside math
	if lname(elem) in ("t",):
		return md_escape(elem.text or "")

	# Fraction: m:f → \frac{num}{den}
	if lname(elem) == "f":
		num = elem.find(f".//{{{M_NS}}}num")
		den = elem.find(f".//{{{M_NS}}}den")
		def _body(node):
			if node is None:
				return ""
			# Prefer child math tokens, fallback to drawing text
			parts = []
			for ch in list(node):
				parts.append(omml_to_latex(ch))
			if not parts:
				parts.append(_concat_texts([node]))
			return "".join(parts)
		return f"\\frac{{{_body(num)}}}{{{_body(den)}}}"

	# Superscript: m:sSup with m:e (base) and m:sup (exp)
	if lname(elem) == "sSup":
		base = elem.find(f".//{{{M_NS}}}e")
		sup = elem.find(f".//{{{M_NS}}}sup")
		return f"{_tex_group(omml_to_latex(base))}^{_tex_group(omml_to_latex(sup))}"

	# Subscript: m:sSub with m:e (base) and m:sub (index)
	if lname(elem) == "sSub":
		base = elem.find(f".//{{{M_NS}}}e")
		sub = elem.find(f".//{{{M_NS}}}sub")
		return f"{_tex_group(omml_to_latex(base))}_{_tex_group(omml_to_latex(sub))}"

	# Root: m:rad with m:deg? and m:e (base)
	if lname(elem) == "rad":
		deg = elem.find(f".//{{{M_NS}}}deg")
		base = elem.find(f".//{{{M_NS}}}e")
		btex = omml_to_latex(base)
		if deg is not None:
			degtex = omml_to_latex(deg)
			return f"\\sqrt[{degtex}]{{{btex}}}"
		return f"\\sqrt{{{btex}}}"

	# If it's an oMath/oMathPara, join all children
	if lname(elem) in ("oMath", "oMathPara"):
		parts = []
		for ch in list(elem):
			parts.append(omml_to_latex(ch))
		if not parts:
			# fallback through drawing text if any
			parts.append(_concat_texts([elem]))
		return "".join(parts)

	# Anything else: try to harvest drawing text; else recurse into children
	text = _concat_texts([elem])
	if text:
		return md_escape(text)
	parts = []
	for ch in list(elem):
		parts.append(omml_to_latex(ch))
	return "".join(parts)


def extract_para_with_math(p) -> str:
	"""Extract one paragraph to Markdown, interleaving OMML equations when possible.
	If we can see OMML nodes at the a:p level, we interleave text and math in order.
	Otherwise, fall back to run_text_with_basic_formatting().
	"""
	try:
		p_el = p._p  # lxml element for a:p
		# Quick test: any math?
		math_hits = []
		if xml_has_lxml:
			math_hits = p_el.xpath('.//m:oMath | .//m:oMathPara', namespaces=NSMAP)
		else:
			# xml.etree doesn't support full xpath; do a coarse search
			for e in p_el.iter():
				if e.tag.endswith('}oMath') or e.tag.endswith('}oMathPara'):
					math_hits.append(e)
		extracted = []
		if math_hits:
			# Interleave child nodes of a:p to preserve order roughly
			for child in list(p_el):
				tag = child.tag
				if tag.endswith('}r'):  # a:r
					# Gather all a:t under this run
					text = "".join(t.text or "" for t in child.findall(f".//{{{A_NS}}}t"))
					if text:
						extracted.append(md_escape(normalize_text(text)))
				elif tag.endswith('}br'):
					extracted.append("  ")  # Markdown line break
				elif tag.endswith('}fld'):
					# Field codes rarely carry visible text here; skip
					continue
				elif tag.endswith('}oMath') or tag.endswith('}oMathPara'):
					try:
						tex = omml_to_latex(child)
						if tex.strip():
							extracted.append(f"${tex}$")
					except Exception:
						# Fallback: placeholder + raw OMML in comment for manual repair
						extracted.append("$/* FIXME:OMML */$")
			else:
				# No math detected → format with bold/italic
				return run_text_with_basic_formatting(p)
			joined = "".join(extracted).strip()
			# Block vs inline: if entire para is just math, render display style
			if joined.startswith("$") and joined.endswith("$") and joined.count("$") == 2 and len(joined) > 2 and normalize_text(joined[1:-1]) != "":
				return f"$${joined[1:-1]}$$"
			return joined
		else:
			return run_text_with_basic_formatting(p)
	except Exception:
		return run_text_with_basic_formatting(p)


# -------------------- Table extraction --------------------

def table_to_markdown(tbl) -> str:
	rows = tbl.rows
	if len(rows) == 0:
		return ""
	# Use first row as header regardless (easy to edit later)
	headers = []
	first_row = rows[0]
	for cell in first_row.cells:
		text = normalize_text("\n".join(para.text for para in cell.text_frame.paragraphs))
		headers.append(md_escape(text))
	# Build table
	md_lines = []
	md_lines.append("| " + " | ".join(h or " " for h in headers) + " |")
	md_lines.append("| " + " | ".join("---" for _ in headers) + " |")
	for r in rows[1:]:
		cols = []
		for cell in r.cells:
			text = normalize_text("\n".join(para.text for para in cell.text_frame.paragraphs))
			cols.append(md_escape(text))
		md_lines.append("| " + " | ".join(cols) + " |")
	return "\n".join(md_lines)


# -------------------- Image extraction --------------------

def export_picture(shape, media_dir: str, slide_idx: int, pic_idx: int) -> str:
	img = shape.image
	ext = img.ext or "png"
	fname = f"slide{slide_idx+1:02d}_img{pic_idx+1:02d}.{ext}"
	fpath = os.path.join(media_dir, fname)
	with open(fpath, "wb") as f:
		f.write(img.blob)
	return fname


# -------------------- Slide → Markdown blocks --------------------

def slide_title(slide, default_idx: int) -> str:
	try:
		t = slide.shapes.title
		if t is not None and t.text and t.text.strip():
			return normalize_text(t.text)
	except Exception:
		pass
	return f"Slide {default_idx+1}"


def shape_alt_or_name(shape) -> str:
	try:
		# python-pptx exposes .name.
		name = getattr(shape, "name", "") or ""
		# Some shapes have alternative text, but API differs; try getattr
		alt = getattr(shape, "alternative_text", "") or getattr(shape, "alt_text", "") or ""
		cand = alt.strip() or name.strip()
		return cand
	except Exception:
		return ""


def paragraph_to_md_lines(p, bullet_char: str = "-") -> list:
	"""Return list of lines for a paragraph, with bullet indentation if any."""
	text = extract_para_with_math(p)
	if text == "":
		return []
	level = getattr(p, "level", 0) or 0
	indent = "  " * int(level)  # two spaces per level for Markdown
	if getattr(p, "bullet", None) or (p.level is not None and p.level > 0):
		return [f"{indent}{bullet_char} {text}"]
	return [f"{indent}{text}"]


def slide_to_blocks(slide, media_dir: str, slide_idx: int):
	"""Yield markdown strings for this slide."""
	# Title
	yield f"# {md_escape(slide_title(slide, slide_idx))}\n"

	# Gather text frames / tables / pictures in reading order
	pic_counter = 0
	for shape in slide.shapes:
		try:
			if getattr(shape, "has_text_frame", False) and shape.has_text_frame:
				for p in shape.text_frame.paragraphs:
					for line in paragraph_to_md_lines(p):
						yield line + "\n"
			elif shape.shape_type == MSO_SHAPE_TYPE.TABLE and getattr(shape, "has_table", False):
				md_tbl = table_to_markdown(shape.table)
				if md_tbl:
					yield "\n" + md_tbl + "\n\n"
			elif shape.shape_type == MSO_SHAPE_TYPE.PICTURE:
				# export picture and add a figure block with a label
				fname = export_picture(shape, media_dir, slide_idx, pic_counter)
				label = f"fig:slide{slide_idx+1:02d}-img{pic_counter+1:02d}"
				alt = shape_alt_or_name(shape) or f"Image {slide_idx+1}.{pic_counter+1}"
				yield f"![{md_escape(alt)}](./{os.path.basename(media_dir)}/{fname}){{#{label}}}\n\n"
				pic_counter += 1
		except Exception:
			# ignore shape errors; continue
			continue


# -------------------- End-to-end conversion --------------------

def convert_pptx_to_qmd(input_pptx: str, output_qmd: str, title: str = None, fmt: str = "revealjs") -> None:
	prs = Presentation(input_pptx)
	if title is None or not title.strip():
		try:
			meta_title = prs.core_properties.title
			if meta_title:
				title = meta_title
		except Exception:
				title = None
	if not title:
		title = os.path.splitext(os.path.basename(input_pptx))[0]

	media_dir = os.path.join(os.path.dirname(output_qmd) or ".", os.path.splitext(os.path.basename(output_qmd))[0] + "_media")
	safe_mkdir(media_dir)

	with open(output_qmd, "w", encoding="utf-8") as out:
		# YAML front matter
		out.write("---\n")
		out.write(f"title: {title}\n")
		out.write(f"format: {fmt}\n")
		out.write("---\n\n")

		for i, slide in enumerate(prs.slides):
			for block in slide_to_blocks(slide, media_dir, i):
				out.write(block)
			out.write("\n")


def main():
	parser = argparse.ArgumentParser(description="Convert PPTX to clean Quarto QMD with best-effort math.")
	parser.add_argument("input", help="Path to input .pptx")
	parser.add_argument("-o", "--output", help="Path to output .qmd; default: <input-basename>.qmd")
	parser.add_argument("--title", help="Override document title")
	parser.add_argument("--format", default="revealjs", choices=["revealjs", "html", "pdf"], help="Quarto output format (front matter)")
	args = parser.parse_args()

	inp = args.input
	if not os.path.isfile(inp):
		print(f"ERROR: File not found: {inp}", file=sys.stderr)
		sys.exit(2)

	outp = args.output or (os.path.splitext(inp)[0] + ".qmd")
	convert_pptx_to_qmd(inp, outp, title=args.title, fmt=args.format)
	print(f"Wrote {outp}")
	print("Note: Images exported to", os.path.splitext(os.path.basename(outp))[0] + "_media/")


if __name__ == "__main__":
	main()

